# 设计文档：优化游戏房间操作方法

## 概述
本文档描述了优化 `changeBet` 和 `addAssistantOrChangeSeat` 两个核心方法的架构设计和实现细节。

## 架构决策

### ADR-1: 采用分层验证策略
**状态**: 已接受  
**日期**: 2025-01-04

#### 背景
方法需要进行多层次的验证（参数、权限、业务规则等），如何组织验证逻辑以保证可读性和可维护性。

#### 决策
采用自顶向下的分层验证策略：
1. **参数验证层**：验证参数完整性和格式
2. **数据存在性验证层**：验证房间、玩家等实体存在性
3. **通用业务规则验证层**：验证游戏状态、座位状态等通用规则
4. **特定业务规则验证层**：验证角色权限、操作条件等特定规则

#### 后果
- ✅ 代码结构清晰，易于理解
- ✅ 验证逻辑独立，易于维护
- ✅ 错误提示明确，用户体验好
- ⚠️ 代码行数增加，但可读性提升

---

### ADR-2: addAssistantOrChangeSeat 实现双重功能
**状态**: 已接受  
**日期**: 2025-01-04

#### 背景
原方法仅支持庄家添加机器人，现需支持玩家换座位功能，考虑是否拆分为两个独立方法。

#### 决策
保持单一方法，通过 `isBanker` 参数区分功能分支：
- `isBanker=true`：庄家添加机器人
- `isBanker=false`：玩家换座位

#### 替代方案
1. 拆分为 `addAssistant` 和 `changeSeat` 两个方法
2. 使用 `action` 参数标识操作类型

#### 后果
- ✅ API 数量不增加，简化前端调用
- ✅ 共享通用验证逻辑，减少重复代码
- ✅ 单一入口便于日志记录和权限控制
- ⚠️ 方法内部逻辑分支增加，需要清晰的注释

---

### ADR-3: 座位交换采用直接覆盖策略
**状态**: 已接受  
**日期**: 2025-01-04

#### 背景
玩家换座位涉及两个座位的数据交换，考虑使用交换还是覆盖策略。

#### 决策
采用直接覆盖策略：
1. 将玩家数据复制到目标座位
2. 将原座位重置为空位

#### 替代方案
1. 交换两个座位的完整数据
2. 使用中间变量进行三步交换

#### 后果
- ✅ 逻辑简单清晰
- ✅ 避免空位数据污染玩家位
- ✅ 符合用户心理模型（移动而非交换）
- ✅ 减少数据不一致的风险

---

## 数据流设计

### changeBet 数据流

```
前端调用
   ↓
API 层（api/index.ts）
   ↓
Request 层（utils/request.ts）
   ↓
Mock API 层（utils/mockData.ts）
   ├─ 参数验证
   ├─ 房间和玩家查找
   ├─ 业务规则验证
   │  ├─ 庄家限制
   │  ├─ 状态限制
   │  ├─ 游戏状态限制
   │  └─ 范围限制
   ├─ 数据更新
   ├─ 本地存储（setRoomInfo）
   └─ 返回结果
   ↓
前端更新状态
```

### addAssistantOrChangeSeat 数据流

```
前端调用
   ↓
API 层（api/index.ts）
   ↓
Request 层（utils/request.ts）
   ↓
Mock API 层（utils/mockData.ts）
   ├─ 参数验证
   ├─ 房间和玩家查找
   ├─ 通用验证
   │  ├─ 游戏状态限制
   │  ├─ 目标座位验证
   │  └─ 庄家位保护
   ├─ 分支逻辑
   │  ├─ [庄家分支]
   │  │  ├─ 权限验证
   │  │  ├─ 生成机器人
   │  │  └─ 数据更新
   │  └─ [玩家分支]
   │     ├─ 权限验证
   │     ├─ 状态验证
   │     ├─ 位置验证
   │     └─ 座位交换
   ├─ 本地存储（setRoomInfo）
   └─ 返回结果
   ↓
前端更新状态
```

---

## 错误处理设计

### 错误码规范
| HTTP 码 | 场景 | 示例 |
|---------|------|------|
| 200 | 成功或无变化 | "下注倍数未改变" |
| 400 | 客户端请求错误 | "参数不完整", "游戏已开始" |
| 403 | 权限不足 | "只有庄家才能添加机器人" |
| 404 | 资源不存在 | "房间不存在", "玩家不在房间中" |

### 错误消息原则
1. **明确性**：清楚说明错误原因
2. **可操作性**：提示用户如何解决
3. **一致性**：相似错误使用相似措辞
4. **友好性**：避免技术术语

---

## 数据验证设计

### changeBet 验证规则矩阵

| 验证项 | 条件 | 错误码 | 错误消息 |
|--------|------|--------|----------|
| 参数完整性 | roomId && userId && bet !== undefined | 400 | "参数不完整" |
| 房间存在性 | room exists | 404 | "房间不存在" |
| 玩家存在性 | player exists | 404 | "玩家不在房间中" |
| 庄家限制 | player.userType !== 1 | 400 | "庄家不能下注" |
| 状态限制 | player.status !== 2 | 400 | "已准备状态不能更改下注" |
| 游戏状态限制 | !room.isGaming && !room.isStart | 400 | "游戏已开始，无法更改下注" |
| 范围限制 | isInteger(bet) && bet >= 1 && bet <= 10 | 400 | "下注倍数必须是1-10之间的整数" |
| 重复检查 | player.bet !== bet | 200 | "下注倍数未改变" |

### addAssistantOrChangeSeat 验证规则矩阵

#### 通用验证
| 验证项 | 条件 | 错误码 | 错误消息 |
|--------|------|--------|----------|
| 参数完整性 | 所有参数存在 | 400 | "参数不完整" |
| 房间存在性 | room exists | 404 | "房间不存在" |
| 座位索引 | 0 <= seatIndex < players.length | 400 | "座位索引无效" |
| 操作者存在性 | operator exists | 404 | "操作玩家不在房间中" |
| 游戏状态 | !room.isGaming && !room.isStart | 400 | "游戏已开始，无法操作" |
| 目标座位 | targetSeat.userType === 4 | 400 | "目标座位已被占用" |
| 庄家位保护 | seatIndex !== 7 | 400 | "不能操作庄家位置" |

#### 庄家分支验证
| 验证项 | 条件 | 错误码 | 错误消息 |
|--------|------|--------|----------|
| 权限验证 | operator.userType === 1 | 403 | "只有庄家才能添加机器人" |

#### 玩家分支验证
| 验证项 | 条件 | 错误码 | 错误消息 |
|--------|------|--------|----------|
| 权限验证 | operator.userType === 2 | 403 | "只有普通玩家才能换座位" |
| 状态验证 | operator.status !== 2 | 400 | "已准备状态不能换座位，请先取消准备" |
| 位置验证 | operatorIndex !== seatIndex | 400 | "您已经在这个位置了" |

---

## 性能考虑

### 时间复杂度
- **changeBet**: O(n) - 需要遍历玩家数组查找目标玩家
- **addAssistantOrChangeSeat**: O(n) - 需要遍历玩家数组查找操作者

### 优化机会
1. 如果玩家数量固定为9，可以使用 Map 或对象索引优化查找
2. 验证规则可以短路求值，尽早返回错误

### 存储考虑
- 使用 `wx.setStorageSync` 同步存储，确保数据一致性
- 每次操作后立即持久化，避免数据丢失

---

## 安全性设计

### 权限控制
1. **操作者身份验证**：必须传递 userId 参数
2. **角色权限检查**：庄家和玩家的操作严格分离
3. **状态前置条件**：特定状态才能执行特定操作

### 数据完整性
1. **原子操作**：数据更新和持久化在同一事务中
2. **状态一致性**：更新后立即验证数据一致性
3. **边界保护**：座位索引、下注范围等严格限制

---

## 可扩展性设计

### 未来扩展点
1. **验证规则配置化**：将验证规则提取为配置文件
2. **操作日志系统**：建立完整的操作审计日志
3. **WebSocket 同步**：实时同步房间状态到其他玩家
4. **撤销/重做**：支持操作的撤销和重做

### 插件化设计
```typescript
interface OperationValidator {
  validate(data: any, context: any): ValidationResult;
}

interface OperationHandler {
  handle(data: any, context: any): Promise<OperationResult>;
}
```

---

## 测试策略

### 单元测试
- 每个验证规则独立测试
- 边界条件覆盖
- 错误路径覆盖

### 集成测试
- 完整操作流程测试
- 多用户场景测试
- 并发操作测试

### 回归测试
- 确保优化不影响现有功能
- 验证向后兼容性

---

## 监控和日志

### 日志级别
- **INFO**: 正常操作（成功的下注、换座位）
- **WARN**: 业务规则拦截（重复下注、权限不足）
- **ERROR**: 系统错误（房间不存在、数据异常）

### 日志格式
```typescript
console.log(`[方法名] 操作者 ${name}(ID:${userId}) 操作描述 从 ${old} 改为 ${new}`);
```

### 关键指标
- 操作成功率
- 错误类型分布
- 平均响应时间

---

## 参考资料
- [TypeScript 最佳实践](https://typescript-eslint.io/rules/)
- [微信小程序开发指南](https://developers.weixin.qq.com/miniprogram/dev/framework/)
- [Clean Code 原则](https://github.com/ryanmcdermott/clean-code-javascript)
